from pymongo import *
import exceptions
import traceback
import json


class ProvenanceStore(object):

    def __init__(self, url):
 
        self.conection = MongoClient(host=url)
        self.db = self.conection["verce-prov"]
        self.lineage = self.db['lineage']
        self.workflow = self.db['workflow']
        
        'too specific here, have to be migrated to gateway-api'
        self.solver = self.db['solver']
        
    'extract information about a list of workflow runs starting from start to limit'    
    
    def getSolverConf(self,path):
        try:
            solver = self.solver.find_one({"_id":path})
            if (solver!=None):
                solver.update({"success":True})
                return solver
            else:
                return {"success":False, "error":"Solver "+path+" not Found"}
            
        except Exception, e:
            return {"success":False, "error":str(e)}
    
    
    
    
    
    
    def getUserRunsValuesRange(self,path,keylist,maxvaluelist,minvaluelist,start,limit):
        elementsDict ={}
        output=None
        runids=[]
        uniques=None
            
        for x in keylist:
            maxval=maxvaluelist.pop(0)
            minval=minvaluelist.pop(0)
            try: 
                maxval =self.num(maxval)
                minval =self.num(minval)
            except Exception,e:
                None
            obj=self.lineage.find({'username':path,'streams.content':{'$elemMatch':{x:{"$lte":maxval,"$gte":minval }}}}).distinct("runId")
            
            if (uniques!=None):
                uniques=list(set(uniques).intersection(set(obj)))
                 
            else:
                uniques=obj
                
            
        
        totalCount=len(uniques)
        
        obj=self.workflow.find({"_id":{"$in":uniques}},{"startTime":-1,"system_id":1,"description":1,"name":1}).sort("startTime",direction=-1)[start:start+limit]
        for x in obj:
            runids.append(x)
        
            
        output = {"runIds":runids};
        output.update({"totalCount": totalCount})
        
        return output
    
    
    def getRunInfo(self, path):
        
         obj = self.workflow.find_one({"_id":path})
         return obj

         
     
    def getUserRuns(self, path, start,limit):
        
        obj=None
        totalCount=None
        output=None
        
        
        obj = self.workflow.find({"username":path},{"startTime":-1,"system_id":1,"description":1,"name":1}).sort("startTime",direction=-1)[start:start+limit]

        totalCount=self.workflow.find({"username":path}).count()
        runids = list()
        
        for x in obj:
                
            runids.append(x)
            
        output = {"runIds":runids};
        output.update({"totalCount": totalCount})
    
        return  output
    
    
    def num(self,s):
        try:
            return int(s)
        except exceptions.ValueError:
            return float(s)

     
    
    
    def getEntitiesBy(self,path,keylist,mtype,start,limit,runId=None,iterationId=None,dataId=None,maxvaluelist=None,minvaluelist=None,valuelist=None):
        totalCount=0;
        cursorsList=list()
        obj=None
        i=0
        ' extract data by annotations either from the whole archive or for a specific runId'
         
        
        if path=="annotations":
            if runId!=None:
                for x in keylist:
                    cursorsList.append(self.lineage.find({'streams.annotations':{'$elemMatch':{'key': x,'val':{'$in':valuelist}}},'runId':runId},{"runId":1,"streams.annotations.$":1,'streams':1,'endTime':1,'errors':1,"parameters":1,})[start:start+limit].sort("endTime",direction=-1))
                    totalCount = totalCount + self.lineage.find({'streams.annotations':{'$elemMatch':{'key': x,'val':{'$in':valuelist}}},'runId':runId},).count()
            else:
                for x in keylist:
                    cursorsList.append(self.lineage.find({'streams.annotations':{'$elemMatch':{'key': x,'val':{'$in':valuelist}}}},{"runId":1,"streams.annotations.$":1,'streams':1,'endTime':1,'errors':1,"parameters":1})[start:start+limit].sort("endTime",direction=-1))
                    totalCount = totalCount + self.lineage.find({'streams.annotations':{'$elemMatch':{'key': x,'val':{'$in':valuelist}}}},).count()
        
        ' extract all the dataset produced by a certain process'
        if path=="generatedby":
            cursorsList.append(self.lineage.find({'_id':iterationId},{"runId":1,"streams":1,"parameters":1,'endTime':1,'errors':1}))
            
            totalCount = totalCount + self.lineage.find({'_id':iterationId},{"streams":1,"parameters":1,'endTime':1}).count()
        
        ' extract a dataset produced by a certain run '            
        if path=="run":        
            cursorsList.append(self.lineage.find({'runId':runId,'streams.id':dataId},{"runId":1,"streams":{"$elemMatch": { "id": dataId}},"parameters":1,'endTime':1,'errors':1}))
            totalCount = totalCount + self.lineage.find({'runId':runId,'streams.id':dataId}).count()
        
        ' extract a dataset containing a certain metadata value over the whole archive '
        if path=="contentmatch-eachtomany":
            if runId!=None:
                for x in keylist:
                
                    cursorsList.append(self.lineage.find({'runId':runId,'streams.content':{'$elemMatch':{x :{'$in':valuelist}}}},{"runId":1,"streams.content.$":1,'streams':1,'endTime':1,'errors':1,"parameters":1})[start:start+limit].sort("endTime",direction=-1))
                    totalCount = totalCount + self.lineage.find({'runId':runId,'streams.content':{'$elemMatch':{x :{'$in':valuelist}}}},).count()
                    cursorsList.append(self.lineage.find({'runId':runId,'streams.content.'+x :{'$in':valuelist}},{"runId":1,"streams.content.$":1,'streams':1,'endTime':1,'errors':1,"parameters":1})[start:start+limit].sort("endTime",direction=-1))
                    totalCount = totalCount + self.lineage.find({'runId':runId,'streams.content.'+x :{'$in':valuelist}}).count()
            else:
                for x in keylist:
                
                    cursorsList.append(self.lineage.find({'streams.content':{'$elemMatch':{x :{'$in':valuelist}}}},{"runId":1,"streams.content.$":1,'streams':1,'endTime':1,'errors':1,"parameters":1})[start:start+limit].sort("endTime",direction=-1))
                    totalCount = totalCount + self.lineage.find({'streams.content':{'$elemMatch':{x :{'$in':valuelist}}}},).count()
                    cursorsList.append(self.lineage.find({'streams.content.'+x :{'$in':valuelist}},{"runId":1,"streams.content.$":1,'streams':1,'endTime':1,'errors':1,"parameters":1})[start:start+limit].sort("endTime",direction=-1))
                    totalCount = totalCount + self.lineage.find({'streams.content.'+x :{'$in':valuelist}}).count()
        
        if path=="contentmatch-eachtoone":
            if runId!=None:
                elementsDict ={}
                for x in keylist:
                    val=valuelist.pop(0)
                    try: 
                        val =self.num(val)
                    except Exception,e:
                        None

                    elementsDict.update({x:val})
                
                cursorsList.append(self.lineage.find({'runId':runId,'streams.format':mtype,'streams.content':{'$elemMatch':elementsDict}},{"runId":1,"streams.content.$":1,'streams':1,'endTime':1,'errors':1,"parameters":1})[start:start+limit].sort("endTime",direction=-1))
                totalCount = totalCount + self.lineage.find({'runId':runId,'streams.format':mtype,'streams.content':{'$elemMatch':elementsDict}},).count()
            else:
                elementsDict ={}
                for x in keylist:
                    for y in valuelist:
                        elementsDict.update({x:y})
                cursorsList.append(self.lineage.find({'streams.content':{'$elemMatch':elementsDict}},{"runId":1,"streams.content.$":1,'streams':1,'endTime':1,'errors':1,"parameters":1})[start:start+limit].sort("endTime",direction=-1))
                totalCount = totalCount + self.lineage.find({'streams.content':{'$elemMatch':elementsDict}},).count()


        if path=="values-range":
            
            elementsDict ={}
            
            for x in keylist:
                maxval=maxvaluelist.pop(0)
                minval=minvaluelist.pop(0)
                try: 
                    maxval =self.num(maxval)
                    minval =self.num(minval)
                except Exception,e:
                    None

                
                elementsDict.update({x:{"$lte":maxval,"$gte":minval }})
            if runId!=None:
                cursorsList.append(self.lineage.find({'runId':runId,'streams.format':mtype,'streams.content':{'$elemMatch':elementsDict}},{"runId":1,"streams.content.$":1,'streams':1,'endTime':1,'errors':1,"parameters":1})[start:start+limit].sort("endTime",direction=-1))
                totalCount=totalCount+self.lineage.find({'runId':runId,'streams.format':mtype,'streams.content':{'$elemMatch':elementsDict}},{"runId":1}).count()
            else:
                cursorsList.append(self.lineage.find({'streams.format':mtype,'streams.content':{'$elemMatch':elementsDict}},{"runId":1,"streams.content.$":1,'streams':1,'endTime':1,'errors':1,"parameters":1})[start:start+limit].sort("endTime",direction=-1))
                 
        artifacts = list()

        for cursor in cursorsList:
            for x in cursor:
                
                for s in x["streams"]:
                    totalCount=totalCount+1
                    s["wasGeneratedBy"]=x["_id"]
                    s["parameters"]=x["parameters"]
                    s["endTime"]=x["endTime"]
                    s["runId"]=x["runId"]
                    s["errors"]=x["errors"]
                    artifacts.append(s)
                    
        
                
        output = {"entities":artifacts};
        output.update({"totalCount": totalCount})
        return  output
         
    def getActivities(self, id,start,limit):
        obj = self.lineage.find({'runId':id},{"runId":1,"instanceId":1,"parameters":1,"endTime":-1,"errors":1,"iterationIndex":1})[start:start+limit].sort("endTime",direction=-1)
        totalCount=self.lineage.find({'runId':id},{"instanceId":1}).count()
        activities = list()
        
        for x in obj:
            activities.append(x)
        output = {"activities":activities};
        output.update({"totalCount": totalCount})
        return  output
    
    def editRun(self, id,doc):
        ret=[]
        response={}
        
        try:
            
            self.workflow.update({"_id":id},{'$set':doc})
        
            response={"success":True}
            response.update({"edit":id}) 
        
        except Exception, err:
            response={"success":False}
            response.update({"error":str(err)})
            traceback.print_exc()
        finally:
            return response
        
        
    def deleteRun(self, id):
        ret=[]
        response={}
        
        try:
            if (self.workflow.find_one({"_id":id})!=None):
                self.lineage.remove({"runId":id})
                self.workflow.remove({"_id":id})
            
                response={"success":True}
                response.update({"delete":id}) 
            else:
                response={"success":False}
                response.update({"error":"Workflow run "+id+" does not exist!"}) 
            
        except Exception, err:
            response={"success":False}
            response.update({"error":str(err)})
            traceback.print_exc()
        finally:
            return response
    
    def insertWorkflow(self, json):
        ret=[]
        response={}
        
        try:
            if type(json) =='list':
        
                for x in json:
                    
                    ret.append(self.workflow.insert(x))
            else:
                ret.append(self.workflow.insert(json))
        
            response={"success":True}
            response.update({"inserts":ret}) 
        
        except Exception, err:
            response={"success":False}
            response.update({"error":str(err)}) 
        finally:
            return response
    
    
    ' insert new data in different collections depending from the document type'

    def updateCollections(self, prov):
        try:
            if prov["type"]=="lineage":
                if(self.workflow.find_one({"_id":prov["runId"]})!=None):
                    return self.lineage.insert(prov)
                else: 
                    raise Exception("Workflow Run not found")
            if prov["type"]=="workflow_run":
             
                return self.workflow.insert(prov)
        
        except Exception, err:
            raise
            
    def insertData(self, prov):
        ret=[]
        response={}
        
        
        try:
            if type(prov).__name__ =='list':
                 
                for x in prov:
                   try:
                       ret.append(self.updateCollections(x))
                   except Exception, err:
                       ret.append({"error":str(err)})
            else:
                try:
                 
                    ret.append(self.updateCollections(prov))
                except Exception, err:
                       ret.append({"error":str(err)})
        
            response={"success":True}
            response.update({"inserts":ret}) 
        
        except Exception, err:
            
            response={"success":False}
            response.update({"error":str(err)}) 
            
        finally:
            return response
    
    
    def getDerivedDataTrace(self, id,level):
         
        xx = self.lineage.find_one({"streams.id":id},{"runId":1});
        xx.update({"dataId":id})
        cursor=self.lineage.find({"derivationIds":{'$elemMatch':{"DerivedFromDatasetID":id}}},{"runId":1,"streams":1});
         
        
        if level>0:
            derivedData=[]
            
            i=0
            for d in cursor:
                i+=1
                if (i<25):
                 
                 
                 
                    for str in d["streams"]:
                     
                        try:
                            derivedData.append(self.getDerivedDataTrace(str["id"],level-1))
                        
                        except Exception, err:
                            None
                 
                 
                
            xx.update({"derivedData":derivedData})
                
            
         
        
      
        return xx
        
    def getTrace(self, id,level):
         
        xx = self.lineage.find_one({"streams.id":id},{"runId":1,"derivationIds":1});
         
         
        xx.update({"id":id})
        if level>=0:
            for derid in xx["derivationIds"]:
                try:
                    derid["wasDerivedFrom"] = self.getTrace(derid["DerivedFromDatasetID"],level-1)
                except Exception, err:
                    None
            return xx
        
    
    
    def filterOnAncestorsValuesRange(self,idlist,keylist,minvaluelist,maxvaluelist):
        filteredIds=[]
        for x in idlist:
            test=self.hasAncestorWithValuesRange(x,keylist,minvaluelist,maxvaluelist)
         #   print test
            if test["hasAncestorWith"]==True:
                filteredIds.append(x)
        
        return filteredIds
    
    def filterOnAncestorsMeta(self,idlist,keylist,valuelist):
        filteredIds=[]
        for x in idlist:
            test=self.hasAncestorWith(x,keylist,valuelist)
         #   print test
            if test["hasAncestorWith"]==True:
                filteredIds.append(x)
        
        return filteredIds
    
    def filterOnMeta(self,idlist,keylist,valuelist):
        filteredIds=[]
        for x in idlist:
            test=self.hasMeta(x,keylist,valuelist)
        #   print test
            if test["hasMeta"]==True:
                filteredIds.append(x)
        
        return filteredIds
            
    
    def hasMeta(self, id, keylist,valuelist):
         
        elementsDict ={}
        
        k=0
        for x in keylist:
            val=valuelist[k]
            k+=1
            try: 
                val =self.num(val)
            except Exception,e:
                None

            elementsDict.update({x:val})
        
        xx = self.lineage.find_one({"streams":{"$elemMatch":{"id":id,'content':{'$elemMatch':elementsDict}}}},{"streams.id":1});
        if (xx!=None):    
            
            return {"hasMeta":True}
                    
                  
        else:
            return {"hasMeta":False}
    
                
    def hasAncestorWithValuesRange(self, id, keylist,minvaluelist,maxvaluelist):
         
        elementsDict ={}
        k=0
        for x in keylist:
            maxval=maxvaluelist[k]
            minval=minvaluelist[k]
            k+=1
            try: 
                maxval =self.num(maxval)
                minval =self.num(minval)
            except Exception,e:
                None
                

            elementsDict.update({x:{"$lte":maxval,"$gte":minval }})
        
        xx = self.lineage.find_one({"streams.id":id},{"runId":1,"derivationIds":1});
        if len(xx["derivationIds"])>0:    
            for derid in xx["derivationIds"]:
                try:
                #    print derid["DerivedFromDatasetID"]
                    anchestor = self.lineage.find_one({"streams":{"$elemMatch":{"id":derid["DerivedFromDatasetID"],'content':{'$elemMatch':elementsDict}}}},{"streams.id":1});
                    
                    if anchestor!=None:
                        return {"hasAncestorWith":True}
                    else:
                        return self.hasAncestorWithValuesRange(derid["DerivedFromDatasetID"],keylist,minvaluelist,maxvaluelist)
                except Exception,e: 
                   traceback.print_exc()
        else:
            return {"hasAncestorWith":False}
        
    
    def hasAncestorWith(self, id, keylist,valuelist):
         
        elementsDict ={}
        
        k=0
        for x in keylist:
            val=valuelist[k]
            k+=1
            try: 
                val =self.num(val)
            except Exception,e:
                None

            elementsDict.update({x:val})
        
        xx = self.lineage.find_one({"streams.id":id},{"runId":1,"derivationIds":1});
        if len(xx["derivationIds"])>0:    
            for derid in xx["derivationIds"]:
                try:
                #    print derid["DerivedFromDatasetID"]
                    anchestor = self.lineage.find_one({"streams":{"$elemMatch":{"id":derid["DerivedFromDatasetID"],'content':{'$elemMatch':elementsDict}}}},{"streams.id":1});
                    
                    if anchestor!=None:
                        return {"hasAncestorWith":True}
                    else:
                        return self.hasAncestorWith(derid["DerivedFromDatasetID"],keylist,valuelist)
                except Exception,e: 
                   traceback.print_exc()
        else:
            return {"hasAncestorWith":False}
       
        
        
    def getTraceConditonalX(self, id, keylist,valuelist):
         
        elementsDict ={}
        
        k=0
        for x in keylist:
            val=valuelist[k]
            k+=1
            try: 
                val =self.num(val)
            except Exception,e:
                None

            elementsDict.update({x:val})
        
        xx = self.lineage.find_one({"streams.id":id,'streams.content':{'$elemMatch':elementsDict}},{"runId":1,"derivationIds":1});
        
        if xx==None:
            xx = self.lineage.find_one({"streams.id":id},{"runId":1,"derivationIds":1});
             
            xx.update({"id":id})
            
            for derid in xx["derivationIds"]:
                try:
                    val = self.getTraceConditonal(derid["DerivedFromDatasetID"],keylist,valuelist)
                     
                    if val!=None:
                        return {"hasAnchestor":True}
                    
                except Exception, err:
                    traceback.print_exc()
            
        else:
            return xx
