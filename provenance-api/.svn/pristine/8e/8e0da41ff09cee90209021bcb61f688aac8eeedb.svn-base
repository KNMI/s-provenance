from pymongo import *
import json


class ProvenanceStore(object):

    def __init__(self, url):
 
        self.conection = MongoClient(host=url)
        self.db = self.conection["verce-prov"]
        self.lineage = self.db['lineage']
        self.workflow = self.db['workflow']
        
    'extract information about a list of workflow runs starting from start to limit'    
    def getWorkflowInfo(self, path, start,limit):
        
        obj=None
        totalCount=None
        output=None
        
        if path=='allruns':
            obj = self.workflow.distinct('_id')[start:start+limit]
            totalCount=len(self.workflow.distinct('_id'))
            runids = list()
        
            for x in obj:
                 
                runids.append(x)
            
            output = {"runIds":runids};
            output.update({"totalCount": totalCount})
        
        else:
            obj = self.workflow.find({"username":path},{"system_id":1,"description":1})[start:start+limit]
            totalCount=self.workflow.find({"username":path}).count()
            runids = list()
        
            for x in obj:
                
                runids.append(x)
            
            output = {"runIds":runids};
            output.update({"totalCount": totalCount})
    
        return  output
    
    
     
    
    
    def getEntitiesBy(self,path,keylist,valuelist,start,limit,runid=None,iterationid=None,dataid=None):
        totalCount=0;
        cursorsList=list()
        obj=None
        i=0
        ' extract data by annotations either from the whole archive or for a specific runId'
        if path=="annotations":
            if runid!=None:
                for x in keylist:
                    cursorsList.append(self.lineage.find({'streams.annotations':{'$elemMatch':{'key': x,'val':{'$in':valuelist}}},'runId':runid},{"runId":1,"streams.annotations.$":1,'streams':1,'endTime':1,"parameters":1,})[start:start+limit].sort("endTime",direction=-1))
                    totalCount = totalCount + self.lineage.find({'streams.annotations':{'$elemMatch':{'key': x,'val':{'$in':valuelist}}},'runId':runid},).count()
            else:
                for x in keylist:
                    cursorsList.append(self.lineage.find({'streams.annotations':{'$elemMatch':{'key': x,'val':{'$in':valuelist}}}},{"runId":1,"streams.annotations.$":1,'streams':1,'endTime':1,"parameters":1})[start:start+limit].sort("endTime",direction=-1))
                    totalCount = totalCount + self.lineage.find({'streams.annotations':{'$elemMatch':{'key': x,'val':{'$in':valuelist}}}},).count()
        
        ' extract all the dataset produced by a certain process'
        if path=="generatedby":
            cursorsList.append(self.lineage.find({'_id':iterationid},{"runId":1,"streams":1,"parameters":1,'endTime':1}))
            totalCount = totalCount + self.lineage.find({'_id':iterationid},{"streams":1,"parameters":1,'endTime':1}).count()
        
        ' extract a dataset produced by a certain run '            
        if path=="run":        
            cursorsList.append(self.lineage.find({'runId':runid,'streams.id':dataid},{"runId":1,"streams":1,"parameters":1,'endTime':1}))
            totalCount = totalCount + self.lineage.find({'runId':runid,'streams.id':dataid}).count()
        
        ' extract a dataset containing a certain metadata value over the whole archive '
        if path=="content":
            for x in keylist:
                print x
                print valuelist
                cursorsList.append(self.lineage.find({'streams.content':{'$elemMatch':{x :{'$in':valuelist}}}},{"runId":1,"streams.content.$":1,'streams':1,'endTime':1,"parameters":1})[start:start+limit].sort("endTime",direction=-1))
                totalCount = totalCount + self.lineage.find({'streams.content':{'$elemMatch':{x :{'$in':valuelist}}}},).count()
                cursorsList.append(self.lineage.find({'streams.content.'+x :{'$in':valuelist}},{"runId":1,"streams.content.$":1,'streams':1,'endTime':1,"parameters":1})[start:start+limit].sort("endTime",direction=-1))
                totalCount = totalCount + self.lineage.find({'streams.content.'+x :{'$in':valuelist}}).count()
        
        artifacts = list()

        for cursor in cursorsList:
            for x in cursor:
                
                for s in x["streams"]:
                    totalCount=totalCount+1
                    s["wasGeneratedBy"]=x["_id"]
                    s["parameters"]=x["parameters"]
                    s["endTime"]=x["endTime"]
                    s["runId"]=x["runId"]
                    artifacts.append(s)
                    
        
                
        output = {"entities":artifacts};
        output.update({"totalCount": totalCount})
        return  output
         
    def getActivities(self, id,start,limit):
        obj = self.lineage.find({'runId':id},{"instanceId":1,"parameters":1,"endTime":-1,"error":1,"iterationIndex":1})[start:start+limit].sort("endTime",direction=-1)
        totalCount=self.lineage.find({'runId':id},{"instanceId":1,"parameters":1,"endTime":-1,"error":1,"iterationIndex":1}).count()
        activities = list()
        
        for x in obj:
            activities.append(x)
        output = {"activities":activities};
        output.update({"totalCount": totalCount})
        return  output
     
    
    
    def insertWorkflow(self, json):
        ret=[]
        response={}
        
        try:
            if type(json) =='list':
        
                for x in json:
                    print "for"
                    ret.append(self.workflow.insert(x))
            else:
                ret.append(self.workflow.insert(json))
        
            response={"success":True}
            response.update({"inserts":ret}) 
        
        except Exception, err:
            response={"success":False}
            response.update({"error":str(err)}) 
        finally:
            return response
    
    
    ' insert new data in different collections depending from the document type'

    def updateCollections(self, prov):
        try:
            if prov["type"]=="lineage":
                return self.lineage.insert(prov)
            if prov["type"]=="workflow_run":
             
                return self.workflow.insert(prov)
        
        except Exception, err:
            raise
            
    def insertData(self, prov):
        ret=[]
        response={}
        
        
        try:
            if type(prov).__name__ =='list':
                 
                for x in prov:
                   try:
                       ret.append(self.updateCollections(x))
                   except Exception, err:
                       ret.append({"error":str(err)})
            else:
                try:
                 
                    ret.append(self.updateCollections(prov))
                except Exception, err:
                       ret.append({"error":str(err)})
        
            response={"success":True}
            response.update({"inserts":ret}) 
        
        except Exception, err:
            
            response={"success":False}
            response.update({"error":str(err)}) 
            
        finally:
            return response
    
    def getTrace(self, id,level):
        
        xx = self.lineage.find_one({"streams.id":id},{"runId":1,"derivationIds":1});
        streams=list()
         
        xx.update({"id":id})
        if level>=0:
            for derid in xx["derivationIds"]:
                try:
                    derid["wasDerivedFrom"] = self.getTrace(derid["DerivedFromDatasetID"],level-1)
                except Exception, err:
                    None
            return xx