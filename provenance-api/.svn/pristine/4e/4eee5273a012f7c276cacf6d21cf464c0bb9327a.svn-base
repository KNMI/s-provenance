from pymongo import *
import exceptions
import traceback
import json


class ProvenanceStore(object):

    def __init__(self, url):
 
        self.conection = MongoClient(host=url)
        self.db = self.conection["verce-prov"]
        self.lineage = self.db['lineage']
        self.workflow = self.db['workflow']
        
    'extract information about a list of workflow runs starting from start to limit'    
    def getWorkflowInfo(self, path, start,limit):
        
        obj=None
        totalCount=None
        output=None
        
        if path=='allruns':
            obj = self.workflow.distinct('_id')[start:start+limit].sort("_id",direction=-1)
            totalCount=len(self.workflow.distinct('_id'))
            runids = list()
        
            for x in obj:
                 
                runids.append(x)
            
            output = {"runIds":runids};
            output.update({"totalCount": totalCount})
        
        else:
            obj = self.workflow.find({"username":path},{"startTime":-1,"system_id":1,"description":1,"name":1}).sort("startTime",direction=-1)[start:start+limit]

            totalCount=self.workflow.find({"username":path}).count()
            runids = list()
        
            for x in obj:
                
                runids.append(x)
            
            output = {"runIds":runids};
            output.update({"totalCount": totalCount})
    
        return  output
    
    
    def num(self,s):
        try:
            return int(s)
        except exceptions.ValueError:
            return float(s)

     
    
    
    def getEntitiesBy(self,path,keylist,valuelist,mtype,start,limit,runId=None,iterationId=None,dataId=None):
        totalCount=0;
        cursorsList=list()
        obj=None
        i=0
        ' extract data by annotations either from the whole archive or for a specific runId'
         
        
        if path=="annotations":
            if runId!=None:
                for x in keylist:
                    cursorsList.append(self.lineage.find({'streams.annotations':{'$elemMatch':{'key': x,'val':{'$in':valuelist}}},'runId':runId},{"runId":1,"streams.annotations.$":1,'streams':1,'endTime':1,'errors':1,"parameters":1,})[start:start+limit].sort("endTime",direction=-1))
                    totalCount = totalCount + self.lineage.find({'streams.annotations':{'$elemMatch':{'key': x,'val':{'$in':valuelist}}},'runId':runId},).count()
            else:
                for x in keylist:
                    cursorsList.append(self.lineage.find({'streams.annotations':{'$elemMatch':{'key': x,'val':{'$in':valuelist}}}},{"runId":1,"streams.annotations.$":1,'streams':1,'endTime':1,'errors':1,"parameters":1})[start:start+limit].sort("endTime",direction=-1))
                    totalCount = totalCount + self.lineage.find({'streams.annotations':{'$elemMatch':{'key': x,'val':{'$in':valuelist}}}},).count()
        
        ' extract all the dataset produced by a certain process'
        if path=="generatedby":
            cursorsList.append(self.lineage.find({'_id':iterationId},{"runId":1,"streams":1,"parameters":1,'endTime':1,'errors':1}))
            totalCount = totalCount + self.lineage.find({'_id':iterationId},{"streams":1,"parameters":1,'endTime':1}).count()
        
        ' extract a dataset produced by a certain run '            
        if path=="run":        
            cursorsList.append(self.lineage.find({'runId':runId,'streams.id':dataId},{"runId":1,"streams":{"$elemMatch": { "id": dataId}},"parameters":1,'endTime':1,'errors':1}))
            totalCount = totalCount + self.lineage.find({'runId':runId,'streams.id':dataId}).count()
        
        ' extract a dataset containing a certain metadata value over the whole archive '
        if path=="contentmatch-eachtomany":
            if runId!=None:
                for x in keylist:
                
                    cursorsList.append(self.lineage.find({'runId':runId,'streams.content':{'$elemMatch':{x :{'$in':valuelist}}}},{"runId":1,"streams.content.$":1,'streams':1,'endTime':1,'errors':1,"parameters":1})[start:start+limit].sort("endTime",direction=-1))
                    totalCount = totalCount + self.lineage.find({'runId':runId,'streams.content':{'$elemMatch':{x :{'$in':valuelist}}}},).count()
                    cursorsList.append(self.lineage.find({'runId':runId,'streams.content.'+x :{'$in':valuelist}},{"runId":1,"streams.content.$":1,'streams':1,'endTime':1,'errors':1,"parameters":1})[start:start+limit].sort("endTime",direction=-1))
                    totalCount = totalCount + self.lineage.find({'runId':runId,'streams.content.'+x :{'$in':valuelist}}).count()
            else:
                for x in keylist:
                
                    cursorsList.append(self.lineage.find({'streams.content':{'$elemMatch':{x :{'$in':valuelist}}}},{"runId":1,"streams.content.$":1,'streams':1,'endTime':1,'errors':1,"parameters":1})[start:start+limit].sort("endTime",direction=-1))
                    totalCount = totalCount + self.lineage.find({'streams.content':{'$elemMatch':{x :{'$in':valuelist}}}},).count()
                    cursorsList.append(self.lineage.find({'streams.content.'+x :{'$in':valuelist}},{"runId":1,"streams.content.$":1,'streams':1,'endTime':1,'errors':1,"parameters":1})[start:start+limit].sort("endTime",direction=-1))
                    totalCount = totalCount + self.lineage.find({'streams.content.'+x :{'$in':valuelist}}).count()
        
        if path=="contentmatch-eachtoone":
            if runId!=None:
                elementsDict ={}
                for x in keylist:
                    val=valuelist.pop(0)
                    try: 
                        val =self.num(val)
                    except Exception,e:
                        traceback.print_exc()

                    elementsDict.update({x:val})
                

                cursorsList.append(self.lineage.find({'runId':runId,'streams.format':mtype,'streams.content':{'$elemMatch':elementsDict}},{"runId":1,"streams.content.$":1,'streams':1,'endTime':1,'errors':1,"parameters":1})[start:start+limit].sort("endTime",direction=-1))
                totalCount = totalCount + self.lineage.find({'runId':runId,'streams.format':mtype,'streams.content':{'$elemMatch':elementsDict}},).count()
            else:
                elementsDict ={}
                for x in keylist:
                    for y in valuelist:
                        elementsDict.update({x:y})
                cursorsList.append(self.lineage.find({'streams.content':{'$elemMatch':elementsDict}},{"runId":1,"streams.content.$":1,'streams':1,'endTime':1,'errors':1,"parameters":1})[start:start+limit].sort("endTime",direction=-1))
                totalCount = totalCount + self.lineage.find({'streams.content':{'$elemMatch':elementsDict}},).count()

        artifacts = list()

        for cursor in cursorsList:
            for x in cursor:
                
                for s in x["streams"]:
                    totalCount=totalCount+1
                    s["wasGeneratedBy"]=x["_id"]
                    s["parameters"]=x["parameters"]
                    s["endTime"]=x["endTime"]
                    s["runId"]=x["runId"]
                    s["errors"]=x["errors"]
                    artifacts.append(s)
                    
        
                
        output = {"entities":artifacts};
        output.update({"totalCount": totalCount})
        return  output
         
    def getActivities(self, id,start,limit):
        obj = self.lineage.find({'runId':id},{"runId":1,"instanceId":1,"parameters":1,"endTime":-1,"errors":1,"iterationIndex":1})[start:start+limit].sort("endTime",direction=-1)
        totalCount=self.lineage.find({'runId':id},{"instanceId":1}).count()
        activities = list()
        
        for x in obj:
            activities.append(x)
        output = {"activities":activities};
        output.update({"totalCount": totalCount})
        return  output
    
    def editWorkflowInfo(self, id,doc):
        ret=[]
        response={}
        
        try:
            
            self.workflow.update({"_id":id},{'$set':doc})
        
            response={"success":True}
            response.update({"edit":id}) 
        
        except Exception, err:
            response={"success":False}
            response.update({"error":str(err)})
            traceback.print_exc()
        finally:
            return response
        
        
    def deleteWorkflowRun(self, id):
        ret=[]
        response={}
        
        try:
            self.lineage.remove({"runId":id})
            self.workflow.remove({"_id":id})
        
            response={"success":True}
            response.update({"delete":id}) 
        
        except Exception, err:
            response={"success":False}
            response.update({"error":str(err)})
            traceback.print_exc()
        finally:
            return response
    
    def insertWorkflow(self, json):
        ret=[]
        response={}
        
        try:
            if type(json) =='list':
        
                for x in json:
                    print "for"
                    ret.append(self.workflow.insert(x))
            else:
                ret.append(self.workflow.insert(json))
        
            response={"success":True}
            response.update({"inserts":ret}) 
        
        except Exception, err:
            response={"success":False}
            response.update({"error":str(err)}) 
        finally:
            return response
    
    
    ' insert new data in different collections depending from the document type'

    def updateCollections(self, prov):
        try:
            if prov["type"]=="lineage":
                return self.lineage.insert(prov)
            if prov["type"]=="workflow_run":
             
                return self.workflow.insert(prov)
        
        except Exception, err:
            raise
            
    def insertData(self, prov):
        ret=[]
        response={}
        
        
        try:
            if type(prov).__name__ =='list':
                 
                for x in prov:
                   try:
                       ret.append(self.updateCollections(x))
                   except Exception, err:
                       ret.append({"error":str(err)})
            else:
                try:
                 
                    ret.append(self.updateCollections(prov))
                except Exception, err:
                       ret.append({"error":str(err)})
        
            response={"success":True}
            response.update({"inserts":ret}) 
        
        except Exception, err:
            
            response={"success":False}
            response.update({"error":str(err)}) 
            
        finally:
            return response
    
    
    def getDerivedDataTrace(self, id,level):
         
        xx = self.lineage.find_one({"streams.id":id},{"runId":1});
        xx.update({"dataId":id})
        cursor=self.lineage.find({"derivationIds":{'$elemMatch':{"DerivedFromDatasetID":id}}},{"runId":1,"streams":1});
         
        
        if level>0:
            derivedData=[]
            for d in cursor:
                 
                 
                 
                 
                for str in d["streams"]:
                     
                    try:
                        derivedData.append(self.getDerivedDataTrace(str["id"],level-1))
                        
                    except Exception, err:
                        print "err"+str(err)
                 
                 
                
            xx.update({"derivedData":derivedData})
                
            
         
        
      
        return xx
        
    def getTrace(self, id,level):
         
        xx = self.lineage.find_one({"streams.id":id},{"runId":1,"derivationIds":1});
         
         
        xx.update({"id":id})
        if level>=0:
            for derid in xx["derivationIds"]:
                try:
                    derid["wasDerivedFrom"] = self.getTrace(derid["DerivedFromDatasetID"],level-1)
                except Exception, err:
                    None
            return xx
        
    
    
    def filterOnAnchestorsMeta(self,idlist,keylist,valuelist):
        filteredIds=[]
        for x in idlist:
            test=self.hasAnchestorWith(x,keylist,valuelist)
         #   print test
            if test["hasAnchestorWith"]==True:
                filteredIds.append(x)
        
        return filteredIds
            
    
    
    def hasAnchestorWith(self, id, keylist,valuelist):
         
        elementsDict ={}
        
        k=0
        for x in keylist:
            val=valuelist[k]
            k+=1
            try: 
                val =self.num(val)
            except Exception,e:
                traceback.print_exc()

            elementsDict.update({x:val})
        
        xx = self.lineage.find_one({"streams.id":id},{"runId":1,"derivationIds":1});
        if len(xx["derivationIds"])>0:    
            for derid in xx["derivationIds"]:
                try:
                #    print derid["DerivedFromDatasetID"]
                    anchestor = self.lineage.find_one({"streams":{"$elemMatch":{"id":derid["DerivedFromDatasetID"],'content':{'$elemMatch':elementsDict}}}},{"streams.id":1});
                    
                    if anchestor!=None:
                        return {"hasAnchestorWith":True}
                    else:
                        return self.hasAnchestorWith(derid["DerivedFromDatasetID"],keylist,valuelist)
                except Exception,e: 
                   traceback.print_exc()
        else:
            return {"hasAnchestorWith":False}
       
        
        
    def getTraceConditonalX(self, id, keylist,valuelist):
         
        elementsDict ={}
        
        k=0
        for x in keylist:
            val=valuelist[k]
            k+=1
            try: 
                val =self.num(val)
            except Exception,e:
                traceback.print_exc()

            elementsDict.update({x:val})
        
        xx = self.lineage.find_one({"streams.id":id,'streams.content':{'$elemMatch':elementsDict}},{"runId":1,"derivationIds":1});
        
        if xx==None:
            xx = self.lineage.find_one({"streams.id":id},{"runId":1,"derivationIds":1});
             
            xx.update({"id":id})
            
            for derid in xx["derivationIds"]:
                try:
                    val = self.getTraceConditonal(derid["DerivedFromDatasetID"],keylist,valuelist)
                    print derid["DerivedFromDatasetID"]
                    if val!=None:
                        return {"hasAnchestor":True}
                    
                except Exception, err:
                    traceback.print_exc()
            
        else:
            return xx
